{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RetroAchievements Development Docs","text":"<p>Welcome to the RetroAchievements Development documentation! These docs provide extensive information on both the conceptual and technical aspects of making achievements.</p>"},{"location":"badgecreation/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"basics/how-ra-works/","title":"How RA Works","text":"<p>RetroAchievements (RA) provides users the ability to earn achievements in retro games from an RA achievement set.  It awards achievements by comparing a game\u2019s memory, henceforth referred to as RAM, to achievement code written by an RA developer.  Achievement code, also known as logic, is a list of memory conditions chosen by the developer, that when all are simultaneously true on a single frame, will award an achievement.</p>"},{"location":"basics/how-ra-works/#what-is-an-achievement-set","title":"What Is an Achievement Set?","text":"<p>An achievement set is the compilation of individual achievements, rich presence and leaderboards for a particular game.  Achievements are comprised of achievement logic, a title, a description, a point value and a badge.  Additionally, a set must contain a Rich Presence script which provides site users information on where active players are in a game.  Sets may have leaderboards that track how well players perform in certain things in a game such as how quickly they can beat stages, how many points they can score and many other things.  RA users interface with all these components and subcomponents.  Each one is a vital part of the player experience.</p>"},{"location":"basics/how-ra-works/#what-is-achievement-code-and-how-is-it-written","title":"What Is Achievement Code and How Is It Written?","text":"<p>RA code is a custom text-based language that is interpreted by RA supporting emulators. This code is constructed by developers, with them having the ability to choose between two alternative toolkits that best fit their personal experience. The Achievement Editor in the RAIntegration toolkit requires no knowledge of coding, and can be compared to finding addresses in emulation-related tools such as Game Genie and Action Replay. On the other hand, RATools is a standalone executable designed for developers who find it more comfortable to write in a scripting language to develop their achievement set. Both the Achievement Editor and RATools produce code that is used for all achievements, leaderboards and Rich Presence.</p>"},{"location":"basics/how-ra-works/#how-is-achievement-code-processed","title":"How Is Achievement Code Processed?","text":"<p>A game\u2019s RAM is its most basic form.  RAM is simply the game's memory addresses and their respective values at any given time.  When processed by a console or emulator, the RAM can be used to recognize what is happening within the game.  Games are processed in a series of frames, generally 60, 50, 30 or 25 per second depending on console and format.  RA processes all unearned achievement logic in a set every frame.  Because of this, developers can create logic such that when all of its conditions are simultaneously true, identify something uniquely precise happening in a game and award an achievement, activate a leaderboard and provide accurate Rich Presence.  It is an achievement developer\u2019s job to understand enough of a game's RAM to be able to construct this logic.</p> <p>Understanding how the RAM works that a developer intends to use in their logic is essential to creating a stable set that awards achievements, submits leaderboard scores and accurately displays Rich Presence only as intended.  RA developers use developer emulator tools to inspect a game's RAM and determine which addresses are responsible for things they intend to use for logic.  Developers have many ways to precisely define exactly which memory conditions must be true in order to construct logic, including retaining knowledge that something occurred previously in memory, but may no longer be true.</p>"},{"location":"basics/how-ra-works/#achievement-logic-and-processing-example","title":"Achievement Logic and Processing Example","text":"<p>As a simple example, to award an achievement for obtaining the hammer in Zelda II: The Adventure of Link, a developer would need to figure out which memory addresses within the game were associated with a few unique things about obtaining the hammer.  There are often many ways to do this.  One way a developer might approach this achievement is to find the addresses for the room ID to ensure the player is in the room with the hammer, also perhaps an area ID to ensure the player is in the right section of the game and lastly an address that indicates whether the player actually gets the hammer.  The reason a room and area ID are important is because when a player loads a save file that has collected the hammer, the memory would indicate that possessed of the hammer goes from untrue to true, but this isn't where the achievement should award.  The room and area ID conditions would ensure that a player was actually obtaining the hammer in game and not just loading a save file that already possessed it.  A solid achievement could be constructed to award when the following is true simultaneously:</p> <p>Room ID = room the hammer is in Area ID = area of game the hammer is in Possesion of hammer changes from not possessed to possessed</p> <p>Here is what this achievement would look like in the Achievement Editor</p> <p></p> Syntax <p>0xH0561=21_0xH076e=2_0xM078b&gt;d0xM078b</p> <p>In this example, address 0x0561 is the room ID and its value is 0x15 when the player is in the room with the hammer, address 0x076e is the area ID and its value is 0x02 when in Death Mountain where the hammer is located and Bit0 of address 0x078b indicates if the player has the hammer.  This bit changes from 0 to 1 when the player acquires the hammer, so the achievement checks for a frame where this bit is greater than it was the previous frame which is precisely when the hammer is obtained since bits can only be either 1 or 0.  If all three conditions are true on the same frame, the achievement is awarded.  This can only happen when the player obtains the hammer while in the hammer room in Death Mountain, not at some other time such as loading a save file.</p> <p>Every frame the player is playing the game, the RAM is being compared to the achievement logic to check if all conditions are true on that frame.  For this example achievement, all conditions can only be true on the same frame when a player is in the room and area where the hammer is obtained and the player obtains the hammer.  When that happens, all of the conditions defined in the logic will be true and the achievement will be immediately awarded.</p>"},{"location":"basics/how-ra-works/#leaderboard-and-rich-presence-code","title":"Leaderboard and Rich Presence Code","text":"<p>Leaderboards function quite similarly to achievements in terms of logic, but need a list of conditions to tell the leaderboard when to activate, when to cancel itself, and when and what value to submit to the leaderboard.  Creating a leaderboard is essentially like creating a few small achievements that will be processed sequentially.</p> <p>Rich Presence code is very similar to achievement and leaderboard code, but is written slightly differently due to the way it is handled by the site.  Rich Presence is written and submitted to RA as a script, as opposed to a string of code like achievements and leaderboards.  It still uses the same fundamental code as achievements and leaderboards, but has some additional features such as custom macros that may be used.</p>"},{"location":"basics/how-ra-works/#take-aways","title":"Take Aways","text":"<p>The key to writing solid code is to first understand what in RAM can be used to recognize a particular game event for which a developer intends to award an achievement, use for a leaderboard or Rich Presence.  The next steps are finding the necessary memory addresses and their values to recognize when the event occurs and constructing logic to create a list of conditions that will only be simultaneously true on the intended frame.</p>"},{"location":"basics/overview/","title":"Overview","text":""},{"location":"basics/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders.</p> <ul> <li>How RA Works</li> <li>Planning an Achievement Set<ul> <li>Deciding on Game Version<ul> <li>Hash and Patch Info</li> </ul> </li> <li>Research</li> <li>Difficulty Scale and Balance</li> <li>Achievement Scoring</li> <li>Set Development Roadmap</li> </ul> </li> <li>The RA Toolkit (RAIntegration)<ul> <li>Setting Up Each Emulator<ul> <li>Recommended Cores and BIOS</li> </ul> </li> <li>Memory Inspector Overview</li> <li>Code Notes</li> <li>Asset List</li> <li>Asset Editor<ul> <li>Achievements</li> <li>Leaderboards</li> <li>Rich Presence</li> </ul> </li> <li>Bookmarks</li> </ul> </li> <li>RAM Digging<ul> <li>Finding Bitflags</li> <li>Finding Pointers</li> <li>Finding Floats</li> </ul> </li> </ul>"},{"location":"basics/set-planning/","title":"Set Planning","text":""},{"location":"basics/set-planning/#planning-an-achievement-set","title":"Planning an Achievement Set","text":""},{"location":"basics/set-planning/#deciding-on-game-version","title":"Deciding on Game Version","text":"<p>Many games were released in different regional formats and versions. Often, a game\u2019s RAM is not consistent between formats and a developer must decide which the set will support. Once a particular game format/version is selected, if it is not already linked to the set, a developer will link, or associate, it with the set using the RA developer toolkit.</p>"},{"location":"basics/set-planning/#selecting-between-ntsc-and-pal-format","title":"Selecting Between NTSC and PAL Format","text":"<p>Games are either NTSC or PAL format depending on which region they were released due to differing worldwide television standards. US and Japanese releases are NTSC while EU releases are PAL. NTSC runs at either ~60 or 30 frames per second (FPS) whereas PAL runs at either ~50 or 25 FPS. Although RAM addresses may be consistent between NTSC and PAL releases, it is not uncommon to find that address values differ between the formats. Additionally, due to FPS differences, achievements based on time will not be consistent between formats in most cases. Creating a set that is equivalent with both formats is possible, but often will take significantly longer development and testing effort to ensure compatibility.</p> <p>There are three options for format selection when considering a set, support NTSC only, support PAL only, or support both. Due to FPS performance, NTSC should be the default format to support. In more advanced consoles, PAL releases typically have additional language support which may be worth sacrificing FPS to support. A developer should consider the tradeoff between FPS and language support. For an RPG, additional language support is likely more valuable to the player base than higher FPS, however for a fast paced game, higher FPS may be more important.</p>"},{"location":"basics/set-planning/#selecting-game-version","title":"Selecting Game Version","text":"<p>Many games were released in different versions, usually to fix bugs that were not known at the time of initial release. In almost all cases, the latest version of a game should be supported by the set. In many cases, supporting earlier versions of the game is viable because the vast majority of RAM will be identical, however earlier versions may contain bugs or exploits that may not result in the intended player experience if abused. There is not an especially compelling reason to support multiple versions of a game in almost all cases.</p>"},{"location":"basics/set-planning/#ra-hashing","title":"RA Hashing","text":"<p>RA uses a hashing algorithm to assign a unique code to each game, called a hash. The hash is then associated or \u201clinked\u201d with a particular achievement set such that RA can reference a particular set of achievement code when a game is being played. Sets can have multiple linked hashes.</p>"},{"location":"basics/set-planning/#patched-games","title":"Patched Games","text":"<p>Patched versions of games may be linked to sets as well for things such as language translations, cosmetic updates, debug function removal or similar reasons. Patches that alter gameplay or difficultly in any way are prohibited without expressed permission from Developer Compliance. A patched game can be linked to the set the same way a standard release version is linked. All linked patched games must have their patches submitted to the RAPatch repository. Information on how to do this is available in the RAPatches forum in the RA discord.</p> <p>Once a developer has linked the hash(es) the set will support, the next step is to plan the achievement set. </p>"},{"location":"basics/set-planning/#achievement-set-plans","title":"Achievement Set Plans","text":"<p>An achievement set plan is working document that a developer uses to guide and track set development progress. The set plan should be understood as a malleable document to be refined throughout development to ensure the best possible final product is produced. It will aid a developer with organizing a set and guide them throughout the development process. It is similar to creating an outline for an essay. A set plan may contain some of or all the following:</p> <ul> <li>a list of intended achievements</li> <li>ideas for potential achievements</li> <li>intended achievement features such as measuring or challenge indicators</li> <li>ideas for titles and descriptions</li> <li>badge creation status</li> <li>planned point values</li> <li>a place to keep notes for future reference</li> <li>individual achievement coding and testing status</li> <li>anticipated RAM digging needs</li> </ul> <p>Having a flexible and iterative plan can significantly improve the overall process and help a developer create the set they envisioned efficiently and effectively. This article will offer techniques used by experienced developers, but it is important to understand that there are many methods by which to develop a set and it\u2019s important for a developer to find a method that works well for them.</p>"},{"location":"basics/set-planning/#fundamentals-of-an-achievement-set-plan","title":"Fundamentals Of An Achievement Set Plan","text":""},{"location":"basics/set-planning/#tools","title":"Tools","text":"<p>Many developers organize their set plans on spreadsheets. Google Sheets is an outstanding tool for creating and managing a set plan. In addition to being a versatile tool by itself, Google Sheets can be shared by multiple users and is quite beneficial in collaborations with other developers and art team members.</p> <p>Example Set Plan sheets</p>"},{"location":"basics/set-planning/#research","title":"Research","text":"<p>The first step in building a set plan is to consider what types of achievements a developer intends to put into the set. Developers will use resources such as long play videos, faqs, wikias and other dedicated websites to learn as much about the game as possible. This is essential to ensuring the set will cover the game\u2019s full content. Even if a developer is already very knowledgeable about a game, it may still behoove them to conduct some research in the event there is content of which they are unaware.</p>"},{"location":"basics/set-planning/#achievement-types","title":"Achievement Types","text":"<p>There are several types of achievements should be considered when developing a set plan. This section will list and explain these acheivement types.</p> <ul> <li>Progression</li> <li>Optional content</li> <li>Collection</li> <li>Challenge</li> <li>Easter egg/for fun</li> </ul>"},{"location":"basics/set-planning/#progression-achievements","title":"Progression Achievements","text":"<p>Progression achievements are awarded for completing specific, mandatory parts of a game as a player progresses towards beating the game in an intended way, including beating the game itself. Progression achievements must be unable to be avoided by a player. RA achievements should be for completing levels or tasks, not for reaching them. Examples of valid progression achievements include:</p> <ul> <li>Defeat Frankenstein\u2019s monster (Castlevania)</li> <li>Defeat Dr. Robotnik the Final Zone (Sonic the Hedgehog)</li> <li>Defeat the Lich and purify the Earth Crystal (Final Fantasy)</li> </ul> <p>Progression achievements should be spaced out throughout the course of a game at relatively consistent intervals and be awarded when significant progress in the game is made. Avoid spoiling major plot points with your achievement descriptions. It\u2019s acceptable to be vague as progression achievements cannot be missed. Points awarded for progression achievements should generally begin at 5 and possibly progress to 10 nearing the end of the game with 25 being the stand point value for a beating the game achievement. Consider the total accumulation of points a player will earn in a playthrough from each of the progression achievements and score them accordingly so the total is a fair reflection of the time and effort requirement.</p>"},{"location":"basics/set-planning/#optional-content-achievements","title":"Optional Content Achievements","text":"<p>Optional content achievements are awarded for completing non-mandatory things in a game such as side-quests or alternate routes. Optional content may sometimes seem like progression, but in cases such as games with warps, may not actually be mandatory when beating a game. Examples of valid optional content achievements include:</p> <ul> <li>Complete the second quest (Castlevania)</li> <li>Collect 6 Chaos Emeralds (Sonic the Hedgehog)</li> <li>Receive King Bahamut\u2019s praise and his reward (class change) (Final Fantasy)</li> </ul> <p>Optional content can best be described as deliberately included game content that is not required to complete the game, but is clearly present to offer additional gameplay experience to players. In many cases, completion of optional content is rewarded by the game. This can be a good indication as to whether the optional content should be considered worthy of a dedicated achievement.</p>"},{"location":"basics/set-planning/#collection-achievements","title":"Collection Achievements","text":"<p>Collection achievements are awarded for collecting things. Common use cases of collection achievements are for acquiring the best weapon in an RPG and collecting all items or treasures in a particular stage or playthrough. Examples of valid collection achievements include:</p> <ul> <li>Break all item containers and find the hidden treasure on Stage 8 (Castlevania)</li> <li>Collect 100 rings (Sonic the Hedgehog)</li> <li>Obtain Masamune (Final Fantasy)</li> </ul> <p>Collection achievements should have some significance driving them such as clearing an area of all its items, obtaining an especially useful, uncommon item, or collecting enough items to be rewarded by the game. If a game has many levels or areas, to avoid spam, consider grouping sections together and creating a single collection achievement that covers several areas.</p>"},{"location":"basics/set-planning/#challenge-achievements","title":"Challenge Achievements","text":"<p>Challenge achievements are awarded for completing developer created challenges within a game. The three most common types of challenges are limitation, time-based and score-based. A limitation challenge requires a player to do something in game with certain restrictions imposed by the developer. Examples of limitation challenge achievements include:</p> <ul> <li>Complete stages 1 through 3 without using a subweapon (Castlevania)</li> <li>Complete Green Hill Zone with no more than 1,000 points (Sonic the Hedgehog)</li> <li>Defeat Tiamat with an attack from a Warrior or Knight (Final Fantasy)</li> </ul> <p>A limitation challenge achievement is awarded for a player completing a task under developer specified restrictions such as beating a stage without dying or being damaged.</p> <p>A time-based challenge achievement is one that requires a task to be done in a certain amount of time. Common time-based challenge achievements are for things like beating levels, beating bosses or collecting a certain number of items in a limited time.</p> <p>A score challenge achievement is awarded for achieving significant scores.</p>"},{"location":"basics/set-planning/#easter-eggfor-fun-achievements","title":"Easter Egg/For Fun Achievements","text":"<p>Some games may have some additional content that is inconsequential and easily missed, but a developer may want to highlight to players who would likely otherwise be unaware of the content. These achievements are typically fairly easy to earn, confer low points, and do not have significant impact on the game play experience. Examples of Easter Egg/For Fun achievements include:</p> <ul> <li>Complete the secret slider puzzle (Final Fantasy)</li> <li>Stay in the bath for a little too long\u2026 (Suikoden)</li> <li>Start a cucco frenzy (The Legend of Zelda: A Link to the Past)</li> </ul> <p>Easter Egg/For Fun achievements are a way to show players the extra details the game developers put in to make the experience more fun than it otherwise would have been.</p>"},{"location":"basics/set-planning/#creating-an-initial-set-plan","title":"Creating An Initial Set Plan","text":"<p>It is helpful to create a rough draft or initial set plan after conducting the research phase of set design. A developer may use one of the sample set plan spreadsheets or use any other form of organizational medium that they choose. Personal preference is important such that a developer continues to utilize the process and receive the maximum benefit. An initial set plan gives a developer a baseline from which to update throughout the course of set development. During development playthroughs, a developer should expect to make numerous revisions to the set plan as achievement ideas are tested for validation, new ideas are considered and set pacing is better understood. This iterative process ensures ideas are refined and fully matured for the set\u2019s release.</p> <p>The two most common methods of organizing an initial set plan are by achievement type and expected chronology. Both methods have their own strengths and weaknesses. Listing achievements by type helps to ensure that nothing is accidentally omitted because it is easier to scrub lists of similar types for totality. Plans ordered by achievement type help ensure a developer maintains a desirable balance in achievement types by grouping types of achievements together for easy comparison. Chronologically ordered lists are easier to work with during the development phase as a developer knows which achievement will be the next one they will encounter and will be better prepared to create necessary saves to use for coding and testing.</p>"},{"location":"basics/set-planning/#refining-the-set-plan-during-development","title":"Refining The Set Plan During Development","text":"<p>Once a developer has an initial set plan, they should begin playing through the game. As they reach sections of the game with planned achievements, they should consider how their current achievement ideas, how well paced the set is to ensure players are rewarded at appropriate and meaningful intervals, and be on the lookout for other achievement opportunities which were not previously considered.</p> <p>Many factors such as new acheivement ideas, implementation feasibility due to memory constraints, trigger timing preference, additional features such as measurements or challenge indicators, and many other may necessitate updates to the set plan. When playing through the game, context that may be helpful for achievement titles or badges may also present itself which should be captured on the set plan. Additionally, a developer may recognize opportunities for creative leaderboards during development which can be added to the plan.</p>"},{"location":"basics/set-planning/#finalizing-the-set-plan","title":"Finalizing The Set Plan","text":"<p>Achievements may be coded as they are encountered during the development playthrough or after the playthrough by utilizing saves. In either case, the set plan is a valuable tool to ensure that all intended achievements, features, and leaderboards are well accounted. At the conclusion of development, the set plan will ultimately serve as a checklist to ensure that exactly what the developer wants in the set has been created and thoroughly tested. When a set plan is ultimately finalized following set testing, the set is ready for promotion.</p>"},{"location":"basics/set-planning/#common-set-planning-mistakes","title":"Common Set Planning Mistakes","text":"<p>The most common set planning mistake is resistance to changing the set plan during development. The set plan is a tool, not a compulsory mandate. Commonly, ideas that may have initially seemed good often require implementation changes to maximize the player experience or outright removal from the plan. A bad player experience may be poor set pacing such as collecting items or beating short stages in rapid succession and receiving an award for each of them, unbalanced challenge difficulty such as one or two challenges that are far more difficult than anything else in an otherwise relatively easy set, or untimely achievement awarding such as awarding achievements at unsatisfying times like at the start of the next stage as opposed to the end of the previous one.</p>"},{"location":"basics/set-planning/#take-aways","title":"Take Aways","text":"<p>It is vital to challenge your ideas throughout development and seek feedback from potential players to take into consideration. Creating a poll in the #poll-me channel of the RA discord is a great way to quickly get feedback from potential players.  Additionally, seek out advice from experienced developers if you are unsure of an idea. Building and using a set plan is a great way to ensure a developer delivers a fantastic experience to the players of the set. Set plans are simple to create and maintain throughout development and will likely save a significant amount of time or result in a better overall set.</p>"},{"location":"leaderboards/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"logic/overview/","title":"Overview","text":""},{"location":"logic/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders. Each section should have multiple examples of the flags/features being used</p> <ul> <li>Flags</li> <li>Blank/\"No Flag\"</li> <li>Pause If<ul> <li>Pause Priority</li> <li>Pause Locks</li> <li>When to use instead of Reset If</li> </ul> </li> <li>Reset If:<ul> <li>When to use instead of Pause If</li> </ul> </li> <li>Reset Next If:<ul> <li>When to use instead of conditional resets in Alt groups</li> </ul> </li> <li>Add Source:<ul> <li>Totals need to be in hex</li> <li>Delta ranges</li> </ul> </li> <li>Sub Source:</li> <li>Add Hits:</li> <li>Sub Hits:</li> <li>Add Address:<ul> <li>Pointers</li> <li>Indexes</li> </ul> </li> <li>And Next:<ul> <li>Multiconditional hits</li> <li>Multiconditional resets/pauses</li> </ul> </li> <li>Or Next:<ul> <li>When to use instead of Alt Groups</li> </ul> </li> <li>Measured and Measured If:</li> <li>Trigger:</li> <li>Chains:</li> <li>Tips and Tricks:</li> <li>Using Sub Source before Add Source with a BitCount to ignore bits</li> <li>Using Trigger and Measured together</li> <li>Features:</li> <li>Hit Counts:<ul> <li>Checkpoint hits</li> <li>Timers</li> </ul> </li> <li>Alt Groups:<ul> <li>When to use instead of Or Next</li> </ul> </li> <li>Types:</li> <li>Memory:</li> <li>Value:</li> <li>Delta:</li> <li>Prior:</li> <li>BCD:</li> <li>Floats:</li> <li>Invert:</li> <li>Memory Sizes:</li> <li>Standard Sizes:<ul> <li>8-Bit</li> <li>16-Bit</li> <li>24-Bit</li> <li>32-Bit</li> </ul> </li> <li>Bits and BitCount:<ul> <li>bit0 and odd numbered values</li> </ul> </li> <li>Lower4 and Upper4:<ul> <li>ASCII scores (30 31 32 instead of 012)</li> </ul> </li> <li>Big Endian:<ul> <li>16-Bit BE</li> <li>24-Bit BE</li> <li>32-Bit BE</li> </ul> </li> <li>Floats:</li> <li>MBF32:<ul> <li>MBF32 LE</li> </ul> </li> <li>Comparisons:</li> <li>Standard Comparisons:<ul> <li><code>= (equal)</code></li> <li><code>&lt; (less than)</code></li> <li><code>&lt;= (less than or equal to)</code></li> <li><code>&gt; (greater than)</code></li> <li><code>&gt;= (greater than or equal to)</code></li> <li><code>!= (not equal to)</code></li> </ul> </li> <li>Flag-Specific Comparisons:<ul> <li><code>* (multiply)</code></li> <li><code>/ (divide)</code></li> <li><code>&amp; (bitwise AND)</code></li> <li><code>^ (XOR)</code></li> </ul> </li> </ul>"},{"location":"ratools/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"resources/condition-syntax/","title":"Condition Syntax","text":""},{"location":"resources/condition-syntax/#memory-sizes","title":"Memory sizes","text":"Size Prefix Example Bit0 <code>0xM</code> <code>0xM01234</code> Bit1 <code>0xN</code> <code>0xN01234</code> Bit2 <code>0xO</code> <code>0xO01234</code> Bit3 <code>0xP</code> <code>0xP01234</code> Bit4 <code>0xQ</code> <code>0xQ01234</code> Bit5 <code>0xR</code> <code>0xR01234</code> Bit6 <code>0xS</code> <code>0xS01234</code> Bit7 <code>0xT</code> <code>0xT01234</code> Lower4 <code>0xL</code> <code>0xL01234</code> Upper4 <code>0xU</code> <code>0xU01234</code> 8bit <code>0xH</code> <code>0xH01234</code> 16bit <code>0x</code> <code>0x 01234</code> 24bit <code>0xW</code> <code>0xW01234</code> 32bit <code>0xX</code> <code>0xX01234</code> 16bit BE <code>0xI</code> <code>0xI01234</code> 24bit BE <code>0xJ</code> <code>0xJ01234</code> 32bit BE <code>0xG</code> <code>0xG01234</code> BitCount <code>0xK</code> <code>0xK01234</code> Float <code>fF</code> <code>fF01234</code> MBF32 <code>fM</code> <code>fM01234</code>"},{"location":"resources/condition-syntax/#prefixes","title":"Prefixes","text":"Modifier Prefix Example Delta <code>d</code> <code>d0xH1234</code> Prior <code>p</code> <code>p0xH1234</code> BCD <code>b</code> <code>b0xH1234</code> Invert <code>~</code> <code>~0xH1234</code>"},{"location":"resources/condition-syntax/#logical-flags","title":"Logical Flags","text":"Flag Prefix Example Reset If <code>R:</code> <code>R:0xH1234=1</code> Reset Next If <code>Z:</code> <code>Z:0xH1234=1</code> Pause If <code>P:</code> <code>P:0xH1234=1</code> And Next <code>N:</code> <code>N:0xH1234=1</code> Or Next <code>O:</code> <code>O:0xH1234=1</code> Add Source <code>A:</code> <code>A:0xH1234=1</code> Sub Source <code>B:</code> <code>B:0xH1234=1</code> AddHits <code>C:</code> <code>C:0xH1234=1</code> SubHits <code>D:</code> <code>D:0xH1234=1</code> AddAddress <code>I:</code> <code>I:0xH1234=1</code> Measured <code>M:</code> <code>M:0xH1234=1</code> Measured% <code>G:</code> <code>G:0xH1234=1</code> Measured If <code>Q:</code> <code>Q:0xH1234=1</code> Trigger <code>T:</code> <code>T:0xH1234=1</code>"},{"location":"resources/emulator-hotkeys/","title":"Emulator Hotkeys","text":""},{"location":"resources/emulator-hotkeys/#bizhawk","title":"BizHawk","text":"<p>May be configured via the Config &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>ESC</code> (<code>Backspace</code> to close overlay)</li> <li>Pause: <code>Pause</code></li> <li>Frame Advance: <code>F</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#pcsx2-with-raintegration-command-line-parameter","title":"PCSX2 (with -raintegration command line parameter)","text":"<p>May be configured via the Settings &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>F1</code> (individual slots can be assigned via <code>Hotkeys</code> &gt; <code>Save State to Slot X</code>)</li> <li>Load State:  <code>F3</code> (individual slots can be assigned via <code>Hotkeys</code> &gt; <code>Save State to Slot X</code>)</li> <li>Change State Index: <code>Shift+F2</code> (prev) / <code>F2</code> (next)</li> <li>Show Overlay: <code>ESC</code></li> <li>Pause: <code>Space</code></li> <li>Frame Advance: Can be assigned via <code>Hotkeys</code> &gt; <code>Frame Advance</code></li> <li>Fast Forward (hold): <code>.</code></li> <li>Fast Forward (toggle): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ralibretro","title":"RALibRetro","text":"<p>May be configured via the Settings &gt; Input &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>ESC</code></li> <li>Pause: <code>P</code></li> <li>Frame Advance: <code>;</code></li> <li>Fast Forward (hold): <code>=</code></li> <li>Fast Forward (toggle): <code>-</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#rameka","title":"RAMeka","text":"<ul> <li>Save State: <code>F5</code></li> <li>Load State: <code>F7</code></li> <li>Change State Index: <code>F6</code> (prev) / <code>F8</code> (next)</li> <li>Show Overlay: <code>F12</code></li> <li>Frame Advance: <code>Ctrl+F12</code></li> <li>Fast Forward (toggle): <code>F2</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ranes","title":"RANes","text":"<p>May be configured via the Config &gt; Map Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>\\</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#raproject64","title":"RAProject64","text":"<p>May be configured via the Options &gt; Configuration dialog (Select Hotkeys &gt; Game playing (windowed))</p> <ul> <li>Save State: <code>F5</code></li> <li>Load State: <code>F7</code></li> <li>Change State Index: <code>1</code>-<code>0</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Fast Forward (toggle): <code>F4</code> (Must enable advanced settings: <code>Options</code> &gt; <code>Configuration</code> &gt; <code>General Settings</code> &gt; uncheck <code>Hide advanced settings</code>)</li> </ul>"},{"location":"resources/emulator-hotkeys/#rapplewin","title":"RAppleWin","text":"<ul> <li>Save State: <code>F11</code></li> <li>Load State: <code>F12</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>Shift+Pause</code></li> <li>Fast Forward (hold): <code>ScrollLock</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#raquasi88","title":"RAQUASI88","text":"<ul> <li>Save State: <code>F12</code> &gt; Misc &gt; Save</li> <li>Load State: <code>F12</code> &gt; Misc &gt; Load</li> <li>Show Overlay: Can be assigned via <code>F12</code> &gt; Key &gt; Assign <code>PAUSE</code> to a function key</li> <li>Fast Forward (hold): Can be assigned via <code>F12</code> &gt; Key &gt; Assign <code>NOWAIT</code> to a function key</li> </ul>"},{"location":"resources/emulator-hotkeys/#rasnes9x","title":"RASnes9x","text":"<ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>\\</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ravba","title":"RAVBA","text":"<ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>Ctrl+N</code></li> <li>Fast Forward (toggle): Can be assigned via <code>Options</code> &gt; <code>Key Shortcuts</code> &gt; <code>Emulation</code> &gt; <code>Turbo Mode</code></li> </ul>"},{"location":"resources/memory-sizes-diagram/","title":"Memory Sizes Diagram","text":""},{"location":"resources/minimumver/","title":"Minimum Required Versions for Logic Features","text":"<p>Sometimes it's useful to know when a feature was added/changed and the implications of these changes, specially if you are working on a ticket. Compare the ticket timestamp to the toolkit releases to determine which behavior the player would have been subject to.</p> Feature RA_Integration RetroArch rcheevos Leaderboard Cancel AND 0.073(31 Aug 2018) 1.7.0(25 Dec 2017) n/a Full 32-bit value support 0.073(31 Aug 2018) 1.7.0(25 Dec 2017) n/a ResetIf/PauseIf HitCount 0.073(31 Aug 2018) 1.7.4(30 Aug 2018) n/a Leaderboard OR 0.073(31 Aug 2018) 1.7.4(30 Aug 2018) n/a Delay achievement processing for 100 frames on load 0.073(31 Aug 2018) n/a n/a Replace 100 frame delay with delayed activation logic 0.075(04 Feb 2019) 1.6.3(28 Jul 2017) n/a AndNext 0.76(21 Jun 2019) 1.7.7(7 May 2019) 8.0(4 May 2019) Prior 0.76(21 Jun 2019) 1.7.7(7 May 2019) 8.0(4 May 2019) 24-bit read 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.0.1(18 Jun 2019) AddAddress 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Measured 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Measured syntax for leaderboard values 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Detect and report Unsupported achievements 0.79(22 May 2021) 1.8.2(25 Dec 2019) n/a OrNext 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) BitCount 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) MeasuredIf 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) Trigger 0.79(22 May 2021) 1.8.7(17 May 2020) 9.0(9 May 2020) Include hits in save states 0.073(31 Aug 2018) 1.9.1(28-Mar 2021) 9.0(9 May 2020) SubHits 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) ResetNextIf 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Ranges in rich presence lookups 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Maxof($) for Measured leaderboard values 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) ResetIf/PauseIf support for Measured leaderboard values 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Big Endian memory reads 1.0(29 Jan 2022) 1.9.9(5 Sep 2021) 10.2(27 Aug 2021) Measured raw/percent flag 1.0(29 Jan 2022) 1.9.9(5 Sep 2021) 10.2(27 Aug 2021) Floating point memory reads 1.0(29 Jan 2022) 1.10.1(6 Mar 2022) 10.3(14 Jan 2022) Built-in macros for rich presence 1.0(29 Jan 2022) 1.10.1(6 Mar 2022) 10.3(14 Jan 2022) MBF32 LE memory read 1.1(15 Nov 2022) 1.13.0(19 Nov 2022) 10.5(12 Nov 2022) XOR modifier 1.1(15 Nov 2022) 1.13.0(19 Nov 2022) 10.5(12 Nov 2022) Float BE memory reads 1.3(TBD) 1.17.0(TBD) 11.0(2 Nov 2023)"},{"location":"resources/overview/","title":"Overview","text":""},{"location":"resources/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders.</p> <ul> <li>Memory Sizes Diagram</li> <li>Condition Syntax</li> <li>Emulator Hotkeys for Developers</li> <li>Console-Specific Tips</li> <li>Minimum Required Versions for Logic Features</li> <li>Game Identification</li> <li>Helpful Sites</li> <li>Glossary of Developer Terms</li> </ul>"},{"location":"richpresence/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"support/overview/","title":"Overview","text":""},{"location":"support/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders. </p> <ul> <li>Protection<ul> <li>Demo Protection<ul> <li>Finding and testing demo addresses</li> </ul> </li> <li>Save Protection<ul> <li>Delta and Prior</li> <li>Using in-game timers</li> <li>Using event flags</li> </ul> </li> <li>Password Protection</li> <li>Cheat Protection</li> <li>Multiplayer Protection</li> <li>BIOS Protection<ul> <li>UniBIOS (Neo Geo CD and Arcade)</li> </ul> </li> <li>Dipswitches</li> <li>Notes on Pause Priority and how other pauses may prevent protections from working</li> </ul> </li> <li>Compatibility Testing<ul> <li>Regional Compatibility</li> <li>Revision Compatibility</li> <li>QoL Hacks</li> </ul> </li> <li>Case Studies/Dev Tips<ul> <li>Writing the same achievement ten different ways</li> <li>Searo's Dev Tips sheet in docs form</li> <li>Dialogue IDs vs Actual Text addresses/values and why the former is the lesser of two evils</li> <li>Why using an unknown address that just happens to always have the same value when you want it to will likely come back to bite you in the ass later.</li> </ul> </li> </ul>"}]}