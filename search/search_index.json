{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RetroAchievements Development Docs","text":"<p>Welcome to the RetroAchievements Development documentation! These docs provide extensive information on both the conceptual and technical aspects of making achievements.</p>"},{"location":"badgecreation/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"basics/how-ra-works/","title":"How RA Works","text":"<p>RetroAchievements (RA) provides users the ability to earn achievements in retro games from an RA achievement set.  It awards achievements by comparing a game\u2019s memory, henceforth referred to as RAM, to achievement code written by an RA developer.  Achievement code, also known as logic, is a list of memory conditions chosen by the developer, that when all are simultaneously true on a single frame, will award an achievement.</p>"},{"location":"basics/how-ra-works/#what-is-an-achievement-set","title":"What Is an Achievement Set?","text":"<p>An achievement set is the compilation of individual achievements, rich presence and leaderboards for a particular game.  Achievements are comprised of achievement logic, a title, a description, a point value and a badge.  Additionally, a set must contain a Rich Presence script which provides site users information on where active players are in a game.  Sets may have leaderboards that track how well players perform in certain things in a game such as how quickly they can beat stages, how many points they can score and many other things.  RA users interface with all these components and subcomponents.  Each one is a vital part of the player experience.</p>"},{"location":"basics/how-ra-works/#what-is-achievement-code-and-how-is-it-written","title":"What Is Achievement Code and How Is It Written?","text":"<p>RA code is a custom text-based language that is interpreted by RA supporting emulators. This code is constructed by developers, with them having the ability to choose between two alternative toolkits that best fit their personal experience. The Achievement Editor in the RAIntegration toolkit requires no knowledge of coding, and can be compared to finding addresses in emulation-related tools such as Game Genie and Action Replay. On the other hand, RATools is a standalone executable designed for developers who find it more comfortable to write in a scripting language to develop their achievement set. Both the Achievement Editor and RATools produce code that is used for all achievements, leaderboards and Rich Presence.</p>"},{"location":"basics/how-ra-works/#how-is-achievement-code-processed","title":"How Is Achievement Code Processed?","text":"<p>A game\u2019s RAM is its most basic form.  RAM is simply the game's memory addresses and their respective values at any given time.  When processed by a console or emulator, the RAM can be used to recognize what is happening within the game.  Games are processed in a series of frames, generally 60, 50, 30 or 25 per second depending on console and format.  RA processes all unearned achievement logic in a set every frame.  Because of this, developers can create logic such that when all of its conditions are simultaneously true, identify something uniquely precise happening in a game and award an achievement, activate a leaderboard and provide accurate Rich Presence.  It is an achievement developer\u2019s job to understand enough of a game's RAM to be able to construct this logic.</p> <p>Understanding how the RAM works that a developer intends to use in their logic is essential to creating a stable set that awards achievements, submits leaderboard scores and accurately displays Rich Presence only as intended.  RA developers use developer emulator tools to inspect a game's RAM and determine which addresses are responsible for things they intend to use for logic.  Developers have many ways to precisely define exactly which memory conditions must be true in order to construct logic, including retaining knowledge that something occurred previously in memory, but may no longer be true.</p>"},{"location":"basics/how-ra-works/#achievement-logic-and-processing-example","title":"Achievement Logic and Processing Example","text":"<p>As a simple example, to award an achievement for obtaining the hammer in Zelda II: The Adventure of Link, a developer would need to figure out which memory addresses within the game were associated with a few unique things about obtaining the hammer.  There are often many ways to do this.  One way a developer might approach this achievement is to find the addresses for the room ID to ensure the player is in the room with the hammer, also perhaps an area ID to ensure the player is in the right section of the game and lastly an address that indicates whether the player actually gets the hammer.  The reason a room and area ID are important is because when a player loads a save file that has collected the hammer, the memory would indicate that possessed of the hammer goes from untrue to true, but this isn't where the achievement should award.  The room and area ID conditions would ensure that a player was actually obtaining the hammer in game and not just loading a save file that already possessed it.  A solid achievement could be constructed to award when the following is true simultaneously:</p> <p>Room ID = room the hammer is in Area ID = area of game the hammer is in Possesion of hammer changes from not possessed to possessed</p> <p>Here is what this achievement would look like in the Achievement Editor</p> <p></p> Syntax <p>0xH0561=21_0xH076e=2_0xM078b&gt;d0xM078b</p> <p>In this example, address 0x0561 is the room ID and its value is 0x15 when the player is in the room with the hammer, address 0x076e is the area ID and its value is 0x02 when in Death Mountain where the hammer is located and Bit0 of address 0x078b indicates if the player has the hammer.  This bit changes from 0 to 1 when the player acquires the hammer, so the achievement checks for a frame where this bit is greater than it was the previous frame which is precisely when the hammer is obtained since bits can only be either 1 or 0.  If all three conditions are true on the same frame, the achievement is awarded.  This can only happen when the player obtains the hammer while in the hammer room in Death Mountain, not at some other time such as loading a save file.</p> <p>Every frame the player is playing the game, the RAM is being compared to the achievement logic to check if all conditions are true on that frame.  For this example achievement, all conditions can only be true on the same frame when a player is in the room and area where the hammer is obtained and the player obtains the hammer.  When that happens, all of the conditions defined in the logic will be true and the achievement will be immediately awarded.</p>"},{"location":"basics/how-ra-works/#leaderboard-and-rich-presence-code","title":"Leaderboard and Rich Presence Code","text":"<p>Leaderboards function quite similarly to achievements in terms of logic, but need a list of conditions to tell the leaderboard when to activate, when to cancel itself, and when and what value to submit to the leaderboard.  Creating a leaderboard is essentially like creating a few small achievements that will be processed sequentially.</p> <p>Rich Presence code is very similar to achievement and leaderboard code, but is written slightly differently due to the way it is handled by the site.  Rich Presence is written and submitted to RA as a script, as opposed to a string of code like achievements and leaderboards.  It still uses the same fundamental code as achievements and leaderboards, but has some additional features such as custom macros that may be used.</p>"},{"location":"basics/how-ra-works/#take-aways","title":"Take Aways","text":"<p>The key to writing solid code is to first understand what in RAM can be used to recognize a particular game event for which a developer intends to award an achievement, use for a leaderboard or Rich Presence.  The next steps are finding the necessary memory addresses and their values to recognize when the event occurs and constructing logic to create a list of conditions that will only be simultaneously true on the intended frame.</p>"},{"location":"basics/overview/","title":"Overview","text":""},{"location":"basics/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders.</p> <ul> <li>How RA Works</li> <li>Planning an Achievement Set<ul> <li>Deciding on Game Version<ul> <li>Hash and Patch Info</li> </ul> </li> <li>Research</li> <li>Difficulty Scale and Balance</li> <li>Achievement Scoring</li> <li>Set Development Roadmap</li> </ul> </li> <li>The RA Toolkit (RAIntegration)<ul> <li>Setting Up Each Emulator<ul> <li>Recommended Cores and BIOS</li> </ul> </li> <li>Memory Inspector Overview</li> <li>Code Notes</li> <li>Asset List</li> <li>Asset Editor<ul> <li>Achievements</li> <li>Leaderboards</li> <li>Rich Presence</li> </ul> </li> <li>Bookmarks</li> </ul> </li> <li>RAM Digging<ul> <li>Finding Bitflags</li> <li>Finding Pointers</li> <li>Finding Floats</li> </ul> </li> </ul>"},{"location":"leaderboards/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"logic/overview/","title":"Overview","text":""},{"location":"logic/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders. Each section should have multiple examples of the flags/features being used</p> <ul> <li>Flags</li> <li>Blank/\"No Flag\"</li> <li>Pause If<ul> <li>Pause Priority</li> <li>Pause Locks</li> <li>When to use instead of Reset If</li> </ul> </li> <li>Reset If:<ul> <li>When to use instead of Pause If</li> </ul> </li> <li>Reset Next If:<ul> <li>When to use instead of conditional resets in Alt groups</li> </ul> </li> <li>Add Source:<ul> <li>Totals need to be in hex</li> <li>Delta ranges</li> </ul> </li> <li>Sub Source:</li> <li>Add Hits:</li> <li>Sub Hits:</li> <li>Add Address:<ul> <li>Pointers</li> <li>Indexes</li> </ul> </li> <li>And Next:<ul> <li>Multiconditional hits</li> <li>Multiconditional resets/pauses</li> </ul> </li> <li>Or Next:<ul> <li>When to use instead of Alt Groups</li> </ul> </li> <li>Measured and Measured If:</li> <li>Trigger:</li> <li>Chains:</li> <li>Tips and Tricks:</li> <li>Using Sub Source before Add Source with a BitCount to ignore bits</li> <li>Using Trigger and Measured together</li> <li>Features:</li> <li>Hit Counts:<ul> <li>Checkpoint hits</li> <li>Timers</li> </ul> </li> <li>Alt Groups:<ul> <li>When to use instead of Or Next</li> </ul> </li> <li>Types:</li> <li>Memory:</li> <li>Value:</li> <li>Delta:</li> <li>Prior:</li> <li>BCD:</li> <li>Floats:</li> <li>Invert:</li> <li>Memory Sizes:</li> <li>Standard Sizes:<ul> <li>8-Bit</li> <li>16-Bit</li> <li>24-Bit</li> <li>32-Bit</li> </ul> </li> <li>Bits and BitCount:<ul> <li>bit0 and odd numbered values</li> </ul> </li> <li>Lower4 and Upper4:<ul> <li>ASCII scores (30 31 32 instead of 012)</li> </ul> </li> <li>Big Endian:<ul> <li>16-Bit BE</li> <li>24-Bit BE</li> <li>32-Bit BE</li> </ul> </li> <li>Floats:</li> <li>MBF32:<ul> <li>MBF32 LE</li> </ul> </li> <li>Comparisons:</li> <li>Standard Comparisons:<ul> <li><code>= (equal)</code></li> <li><code>&lt; (less than)</code></li> <li><code>&lt;= (less than or equal to)</code></li> <li><code>&gt; (greater than)</code></li> <li><code>&gt;= (greater than or equal to)</code></li> <li><code>!= (not equal to)</code></li> </ul> </li> <li>Flag-Specific Comparisons:<ul> <li><code>* (multiply)</code></li> <li><code>/ (divide)</code></li> <li><code>&amp; (bitwise AND)</code></li> <li><code>^ (XOR)</code></li> </ul> </li> </ul>"},{"location":"ratools/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"resources/condition-syntax/","title":"Condition Syntax","text":""},{"location":"resources/condition-syntax/#memory-sizes","title":"Memory sizes","text":"Size Prefix Example Bit0 <code>0xM</code> <code>0xM01234</code> Bit1 <code>0xN</code> <code>0xN01234</code> Bit2 <code>0xO</code> <code>0xO01234</code> Bit3 <code>0xP</code> <code>0xP01234</code> Bit4 <code>0xQ</code> <code>0xQ01234</code> Bit5 <code>0xR</code> <code>0xR01234</code> Bit6 <code>0xS</code> <code>0xS01234</code> Bit7 <code>0xT</code> <code>0xT01234</code> Lower4 <code>0xL</code> <code>0xL01234</code> Upper4 <code>0xU</code> <code>0xU01234</code> 8bit <code>0xH</code> <code>0xH01234</code> 16bit <code>0x</code> <code>0x 01234</code> 24bit <code>0xW</code> <code>0xW01234</code> 32bit <code>0xX</code> <code>0xX01234</code> 16bit BE <code>0xI</code> <code>0xI01234</code> 24bit BE <code>0xJ</code> <code>0xJ01234</code> 32bit BE <code>0xG</code> <code>0xG01234</code> BitCount <code>0xK</code> <code>0xK01234</code> Float <code>fF</code> <code>fF01234</code> MBF32 <code>fM</code> <code>fM01234</code>"},{"location":"resources/condition-syntax/#prefixes","title":"Prefixes","text":"Modifier Prefix Example Delta <code>d</code> <code>d0xH1234</code> Prior <code>p</code> <code>p0xH1234</code> BCD <code>b</code> <code>b0xH1234</code> Invert <code>~</code> <code>~0xH1234</code>"},{"location":"resources/condition-syntax/#logical-flags","title":"Logical Flags","text":"Flag Prefix Example Reset If <code>R:</code> <code>R:0xH1234=1</code> Reset Next If <code>Z:</code> <code>Z:0xH1234=1</code> Pause If <code>P:</code> <code>P:0xH1234=1</code> And Next <code>N:</code> <code>N:0xH1234=1</code> Or Next <code>O:</code> <code>O:0xH1234=1</code> Add Source <code>A:</code> <code>A:0xH1234=1</code> Sub Source <code>B:</code> <code>B:0xH1234=1</code> AddHits <code>C:</code> <code>C:0xH1234=1</code> SubHits <code>D:</code> <code>D:0xH1234=1</code> AddAddress <code>I:</code> <code>I:0xH1234=1</code> Measured <code>M:</code> <code>M:0xH1234=1</code> Measured% <code>G:</code> <code>G:0xH1234=1</code> Measured If <code>Q:</code> <code>Q:0xH1234=1</code> Trigger <code>T:</code> <code>T:0xH1234=1</code>"},{"location":"resources/emulator-hotkeys/","title":"Emulator Hotkeys","text":""},{"location":"resources/emulator-hotkeys/#bizhawk","title":"BizHawk","text":"<p>May be configured via the Config &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>ESC</code> (<code>Backspace</code> to close overlay)</li> <li>Pause: <code>Pause</code></li> <li>Frame Advance: <code>F</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#pcsx2-with-raintegration-command-line-parameter","title":"PCSX2 (with -raintegration command line parameter)","text":"<p>May be configured via the Settings &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>F1</code> (individual slots can be assigned via <code>Hotkeys</code> &gt; <code>Save State to Slot X</code>)</li> <li>Load State:  <code>F3</code> (individual slots can be assigned via <code>Hotkeys</code> &gt; <code>Save State to Slot X</code>)</li> <li>Change State Index: <code>Shift+F2</code> (prev) / <code>F2</code> (next)</li> <li>Show Overlay: <code>ESC</code></li> <li>Pause: <code>Space</code></li> <li>Frame Advance: Can be assigned via <code>Hotkeys</code> &gt; <code>Frame Advance</code></li> <li>Fast Forward (hold): <code>.</code></li> <li>Fast Forward (toggle): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ralibretro","title":"RALibRetro","text":"<p>May be configured via the Settings &gt; Input &gt; Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>ESC</code></li> <li>Pause: <code>P</code></li> <li>Frame Advance: <code>;</code></li> <li>Fast Forward (hold): <code>=</code></li> <li>Fast Forward (toggle): <code>-</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#rameka","title":"RAMeka","text":"<ul> <li>Save State: <code>F5</code></li> <li>Load State: <code>F7</code></li> <li>Change State Index: <code>F6</code> (prev) / <code>F8</code> (next)</li> <li>Show Overlay: <code>F12</code></li> <li>Frame Advance: <code>Ctrl+F12</code></li> <li>Fast Forward (toggle): <code>F2</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ranes","title":"RANes","text":"<p>May be configured via the Config &gt; Map Hotkeys dialog</p> <ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>\\</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#raproject64","title":"RAProject64","text":"<p>May be configured via the Options &gt; Configuration dialog (Select Hotkeys &gt; Game playing (windowed))</p> <ul> <li>Save State: <code>F5</code></li> <li>Load State: <code>F7</code></li> <li>Change State Index: <code>1</code>-<code>0</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Fast Forward (toggle): <code>F4</code> (Must enable advanced settings: <code>Options</code> &gt; <code>Configuration</code> &gt; <code>General Settings</code> &gt; uncheck <code>Hide advanced settings</code>)</li> </ul>"},{"location":"resources/emulator-hotkeys/#rapplewin","title":"RAppleWin","text":"<ul> <li>Save State: <code>F11</code></li> <li>Load State: <code>F12</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>Shift+Pause</code></li> <li>Fast Forward (hold): <code>ScrollLock</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#raquasi88","title":"RAQUASI88","text":"<ul> <li>Save State: <code>F12</code> &gt; Misc &gt; Save</li> <li>Load State: <code>F12</code> &gt; Misc &gt; Load</li> <li>Show Overlay: Can be assigned via <code>F12</code> &gt; Key &gt; Assign <code>PAUSE</code> to a function key</li> <li>Fast Forward (hold): Can be assigned via <code>F12</code> &gt; Key &gt; Assign <code>NOWAIT</code> to a function key</li> </ul>"},{"location":"resources/emulator-hotkeys/#rasnes9x","title":"RASnes9x","text":"<ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>\\</code></li> <li>Fast Forward (hold): <code>Tab</code></li> </ul>"},{"location":"resources/emulator-hotkeys/#ravba","title":"RAVBA","text":"<ul> <li>Save State: <code>Shift+F1</code> - <code>Shift+F10</code></li> <li>Load State: <code>F1</code> - <code>F10</code></li> <li>Show Overlay: <code>Pause</code></li> <li>Frame Advance: <code>Ctrl+N</code></li> <li>Fast Forward (toggle): Can be assigned via <code>Options</code> &gt; <code>Key Shortcuts</code> &gt; <code>Emulation</code> &gt; <code>Turbo Mode</code></li> </ul>"},{"location":"resources/memory-sizes-diagram/","title":"Memory Sizes Diagram","text":""},{"location":"resources/minimumver/","title":"Minimum Required Versions for Logic Features","text":"<p>Sometimes it's useful to know when a feature was added/changed and the implications of these changes, specially if you are working on a ticket. Compare the ticket timestamp to the toolkit releases to determine which behavior the player would have been subject to.</p> Feature RA_Integration RetroArch rcheevos Leaderboard Cancel AND 0.073(31 Aug 2018) 1.7.0(25 Dec 2017) n/a Full 32-bit value support 0.073(31 Aug 2018) 1.7.0(25 Dec 2017) n/a ResetIf/PauseIf HitCount 0.073(31 Aug 2018) 1.7.4(30 Aug 2018) n/a Leaderboard OR 0.073(31 Aug 2018) 1.7.4(30 Aug 2018) n/a Delay achievement processing for 100 frames on load 0.073(31 Aug 2018) n/a n/a Replace 100 frame delay with delayed activation logic 0.075(04 Feb 2019) 1.6.3(28 Jul 2017) n/a AndNext 0.76(21 Jun 2019) 1.7.7(7 May 2019) 8.0(4 May 2019) Prior 0.76(21 Jun 2019) 1.7.7(7 May 2019) 8.0(4 May 2019) 24-bit read 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.0.1(18 Jun 2019) AddAddress 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Measured 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Measured syntax for leaderboard values 0.77(30 Nov 2019) 1.8.2(25 Dec 2019) 8.1(21 Nov 2019) Detect and report Unsupported achievements 0.79(22 May 2021) 1.8.2(25 Dec 2019) n/a OrNext 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) BitCount 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) MeasuredIf 0.78(18 May 2020) 1.8.7(17 May 2020) 9.0(9 May 2020) Trigger 0.79(22 May 2021) 1.8.7(17 May 2020) 9.0(9 May 2020) Include hits in save states 0.073(31 Aug 2018) 1.9.1(28-Mar 2021) 9.0(9 May 2020) SubHits 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) ResetNextIf 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Ranges in rich presence lookups 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Maxof($) for Measured leaderboard values 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) ResetIf/PauseIf support for Measured leaderboard values 0.79(22 May 2021) 1.9.4(29 May 2021) 10.0(15 May 2021) Big Endian memory reads 1.0(29 Jan 2022) 1.9.9(5 Sep 2021) 10.2(27 Aug 2021) Measured raw/percent flag 1.0(29 Jan 2022) 1.9.9(5 Sep 2021) 10.2(27 Aug 2021) Floating point memory reads 1.0(29 Jan 2022) 1.10.1(6 Mar 2022) 10.3(14 Jan 2022) Built-in macros for rich presence 1.0(29 Jan 2022) 1.10.1(6 Mar 2022) 10.3(14 Jan 2022) MBF32 LE memory read 1.1(15 Nov 2022) 1.13.0(19 Nov 2022) 10.5(12 Nov 2022) XOR modifier 1.1(15 Nov 2022) 1.13.0(19 Nov 2022) 10.5(12 Nov 2022) Float BE memory reads 1.3(TBD) 1.17.0(TBD) 11.0(2 Nov 2023)"},{"location":"resources/overview/","title":"Overview","text":""},{"location":"resources/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders.</p> <ul> <li>Memory Sizes Diagram</li> <li>Condition Syntax</li> <li>Emulator Hotkeys for Developers</li> <li>Console-Specific Tips</li> <li>Minimum Required Versions for Logic Features</li> <li>Game Identification</li> <li>Helpful Sites</li> <li>Glossary of Developer Terms</li> </ul>"},{"location":"richpresence/overview/","title":"Overview","text":"<p>placeholder - WIP</p>"},{"location":"support/overview/","title":"Overview","text":""},{"location":"support/overview/#wip-outline-of-this-section","title":"WIP Outline of this section","text":"<p>Some items in the list are just notes/reminders. </p> <ul> <li>Protection<ul> <li>Demo Protection<ul> <li>Finding and testing demo addresses</li> </ul> </li> <li>Save Protection<ul> <li>Delta and Prior</li> <li>Using in-game timers</li> <li>Using event flags</li> </ul> </li> <li>Password Protection</li> <li>Cheat Protection</li> <li>Multiplayer Protection</li> <li>BIOS Protection<ul> <li>UniBIOS (Neo Geo CD and Arcade)</li> </ul> </li> <li>Dipswitches</li> <li>Notes on Pause Priority and how other pauses may prevent protections from working</li> </ul> </li> <li>Compatibility Testing<ul> <li>Regional Compatibility</li> <li>Revision Compatibility</li> <li>QoL Hacks</li> </ul> </li> <li>Case Studies/Dev Tips<ul> <li>Writing the same achievement ten different ways</li> <li>Searo's Dev Tips sheet in docs form</li> <li>Dialogue IDs vs Actual Text addresses/values and why the former is the lesser of two evils</li> <li>Why using an unknown address that just happens to always have the same value when you want it to will likely come back to bite you in the ass later.</li> </ul> </li> </ul>"}]}